

#include <bits/stdc++.h>
using namespace std;

/* =========================
   1) Binary Search (iterative)
   ========================= */
int binary_search_iter(const vector<int>& arr, int key) {
    int l = 0, r = (int)arr.size() - 1;
    while (l <= r) {
        int mid = l + (r - l) / 2;
        if (arr[mid] == key) return mid;
        if (arr[mid] < key) l = mid + 1;
        else r = mid - 1;
    }
    return -1;
}

/* =========================
   2) Bubble Sort (demo with given array)
   ========================= */
void bubble_sort(vector<int>& a) {
    int n = (int)a.size();
    for (int i = 0; i < n-1; ++i) {
        bool swapped = false;
        for (int j = 0; j < n-1-i; ++j) {
            if (a[j] > a[j+1]) {
                swap(a[j], a[j+1]);
                swapped = true;
            }
        }
        if (!swapped) break;
    }
}

/* =========================
   3) Missing number in sorted array
   (a) Linear
   (b) Binary-search-based
   Note: array contains distinct ints from 1..n with exactly one missing and is sorted
   ========================= */
int missing_linear(const vector<int>& arr, int n) {
    // arr length is n-1
    for (int i = 0; i < (int)arr.size(); ++i) {
        if (arr[i] != i + 1) return i + 1; // expected i+1
    }
    return n; // if all matched, missing is n
}

int missing_binary(const vector<int>& arr, int n) {
    int l = 0, r = (int)arr.size() - 1;
    while (l <= r) {
        int mid = l + (r - l) / 2;
        if (arr[mid] == mid + 1) {
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    return l + 1; // position where mismatch starts -> missing number
}

/* =========================
   4) String related programs
   (a) concat, (b) reverse, (c) delete vowels, (d) sort strings, (e) tolower
   ========================= */
string concat_strings(const string& a, const string& b) {
    return a + b;
}
string reverse_string(string s) {
    reverse(s.begin(), s.end());
    return s;
}
string delete_vowels(const string& s) {
    string out;
    for (char c : s) {
        char lc = tolower(c);
        if (!(lc=='a' || lc=='e' || lc=='i' || lc=='o' || lc=='u')) out.push_back(c);
    }
    return out;
}
vector<string> sort_strings_alphabetical(vector<string> arr) {
    sort(arr.begin(), arr.end());
    return arr;
}
char upper_to_lower(char c) {
    if (c >= 'A' && c <= 'Z') return char(c - 'A' + 'a');
    return c;
}

/* =========================
   5) Space-efficient storage for special matrices
   We'll implement small helper classes:
   - DiagonalMatrix: store n elements
   - TridiagonalMatrix: store lower, main, upper arrays
   - LowerTriangular: store n*(n+1)/2
   - UpperTriangular: store n*(n+1)/2
   - Symmetric: store lower (or upper) triangular only
   All use 0-based indices externally.
   ========================= */

struct DiagonalMatrix {
    int n;
    vector<long long> a; // a[i] == A[i][i]
    DiagonalMatrix(int n=0): n(n), a(n, 0) {}
    void set(int i, int j, long long val) {
        if (i==j) a[i] = val;
        else if (val != 0) {
            cerr << "Warning: storing non-zero at non-diagonal ignored\n";
        }
    }
    long long get(int i, int j) const {
        return (i==j ? a[i] : 0);
    }
};

struct TriDiagonal {
    int n;
    vector<long long> lower; // size n-1
    vector<long long> main;  // size n
    vector<long long> upper; // size n-1
    TriDiagonal(int n=0): n(n), lower(max(0,n-1),0), main(n,0), upper(max(0,n-1),0) {}
    void set(int i, int j, long long val) {
        if (i==j) main[i]=val;
        else if (i==j+1) lower[j]=val;
        else if (i+1==j) upper[i]=val;
        else if (val!=0) cerr << "Warning: non-tridiagonal position ignored\n";
    }
    long long get(int i, int j) const {
        if (i==j) return main[i];
        if (i==j+1) return lower[j];
        if (i+1==j) return upper[i];
        return 0LL;
    }
};

struct LowerTriangular {
    int n;
    vector<long long> data; // size n*(n+1)/2
    LowerTriangular(int n=0): n(n), data((n*(n+1))/2,0) {}
    int idx(int i, int j) const {
        // 0-based i>=j
        return (i*(i+1))/2 + j;
    }
    void set(int i, int j, long long val) {
        if (i < j && val != 0) cerr << "Warning: trying to set non-zero above diagonal\n";
        if (i >= j) data[idx(i,j)] = val;
    }
    long long get(int i, int j) const {
        if (i < j) return 0;
        return data[idx(i,j)];
    }
};

struct UpperTriangular {
    int n;
    vector<long long> data; // size n*(n+1)/2
    UpperTriangular(int n=0): n(n), data((n*(n+1))/2,0) {}
    int idx(int i, int j) const {
        // store row-wise upper triangular. i<=j
        // offset = sum_{r=0}^{i-1} (n-r) = i*n - (i*(i-1))/2
        int offset = i*n - (i*(i-1))/2;
        return offset + (j - i);
    }
    void set(int i, int j, long long val) {
        if (i > j && val != 0) cerr << "Warning: trying to set non-zero below diagonal\n";
        if (i <= j) data[idx(i,j)] = val;
    }
    long long get(int i, int j) const {
        if (i > j) return 0;
        return data[idx(i,j)];
    }
};

struct SymmetricMatrix {
    int n;
    vector<long long> data; // store lower triangular as in LowerTriangular
    SymmetricMatrix(int n=0): n(n), data((n*(n+1))/2,0) {}
    int idx(int i, int j) const {
        if (i >= j) return (i*(i+1))/2 + j;
        return (j*(j+1))/2 + i; // symmetric swap
    }
    void set(int i, int j, long long val) {
        data[idx(i,j)] = val;
    }
    long long get(int i, int j) const {
        return data[idx(i,j)];
    }
};

/* =========================
   6) Sparse Matrix (triplet) operations
   We'll represent as vector<tuple<int,int,long long>> triples
   with (row, col, value). Rows & cols are 0-based.
   Operations: transpose, addition, multiplication
   ========================= */
using Trip = tuple<int,int,long long>;

struct SparseTriplet {
    int rows, cols;
    vector<Trip> triples;
    SparseTriplet(int r=0, int c=0): rows(r), cols(c) {}
    void add_triplet(int r, int c, long long v) {
        if (v != 0) triples.emplace_back(r,c,v);
    }
    SparseTriplet transpose() const {
        SparseTriplet t(cols, rows);
        for (auto &tp : triples) {
            int r,c; long long v;
            tie(r,c,v) = tp;
            t.add_triplet(c,r,v);
        }
        // sort by row,col
        sort(t.triples.begin(), t.triples.end(), [](const Trip& a, const Trip& b){
            if (get<0>(a) != get<0>(b)) return get<0>(a) < get<0>(b);
            return get<1>(a) < get<1>(b);
        });
        return t;
    }
    SparseTriplet add(const SparseTriplet& B) const {
        if (rows != B.rows || cols != B.cols) throw runtime_error("Dimension mismatch");
        SparseTriplet C(rows, cols);
        // merge by (r,c)
        vector<Trip> A_sorted = triples, B_sorted = B.triples;
        sort(A_sorted.begin(), A_sorted.end(), [](const Trip& a, const Trip& b){
            if (get<0>(a)!=get<0>(b)) return get<0>(a)<get<0>(b);
            return get<1>(a)<get<1>(b);
        });
        sort(B_sorted.begin(), B_sorted.end(), [](const Trip& a, const Trip& b){
            if (get<0>(a)!=get<0>(b)) return get<0>(a)<get<0>(b);
            return get<1>(a)<get<1>(b);
        });
        size_t i=0,j=0;
        while (i<A_sorted.size() && j<B_sorted.size()) {
            auto A = A_sorted[i];
            auto Bv = B_sorted[j];
            pair<int,int> pa = {get<0>(A), get<1>(A)};
            pair<int,int> pb = {get<0>(Bv), get<1>(Bv)};
            if (pa < pb) { C.add_triplet(get<0>(A), get<1>(A), get<2>(A)); ++i; }
            else if (pb < pa) { C.add_triplet(get<0>(Bv), get<1>(Bv), get<2>(Bv)); ++j; }
            else {
                long long sum = get<2>(A) + get<2>(Bv);
                if (sum != 0) C.add_triplet(pa.first, pa.second, sum);
                ++i; ++j;
            }
        }
        while (i < A_sorted.size()) { auto A = A_sorted[i++]; C.add_triplet(get<0>(A), get<1>(A), get<2>(A)); }
        while (j < B_sorted.size()) { auto Bv = B_sorted[j++]; C.add_triplet(get<0>(Bv), get<1>(Bv), get<2>(Bv)); }
        return C;
    }
    SparseTriplet multiply(const SparseTriplet& B) const {
        if (cols != B.rows) throw runtime_error("Dimension mismatch for multiplication");
        // convert B to map by row
        unordered_map<int, vector<pair<int,long long>>> brow; // row -> (col,val)
        for (auto &t : B.triples) {
            int r = get<0>(t), c = get<1>(t); long long v = get<2>(t);
            brow[r].push_back({c,v});
        }
        // For faster accumulation use map from (i,j)->value
        unordered_map<long long, long long> acc; // key = i*(C)+j where C = B.cols
        long long Cc = B.cols;
        for (auto &t : triples) {
            int r = get<0>(t), k = get<1>(t);
            long long v = get<2>(t);
            if (brow.find(k) == brow.end()) continue;
            for (auto &p : brow[k]) {
                int j = p.first; long long bv = p.second;
                long long key = r * Cc + j;
                acc[key] += v * bv;
            }
        }
        SparseTriplet R(rows, B.cols);
        for (auto &kv : acc) {
            if (kv.second != 0) {
                long long key = kv.first;
                int i = (int)(key / Cc);
                int j = (int)(key % Cc);
                R.add_triplet(i,j,kv.second);
            }
        }
        // sort triplets
        sort(R.triples.begin(), R.triples.end(), [](const Trip& a, const Trip& b){
            if (get<0>(a)!=get<0>(b)) return get<0>(a) < get<0>(b);
            return get<1>(a) < get<1>(b);
        });
        return R;
    }
    void print() const {
        cout << "SparseTriplet (" << rows << "x" << cols << "), nz=" << triples.size() << "\n";
        for (auto &t : triples) {
            cout << "(" << get<0>(t) << "," << get<1>(t) << ")=" << get<2>(t) << "\n";
        }
    }
};

/* =========================
   7) Count inversions using merge sort (O(n log n))
   ========================= */
long long merge_count_inv(vector<long long>& a, int l, int r) {
    if (r - l <= 1) return 0;
    int m = (l + r) / 2;
    long long inv = merge_count_inv(a, l, m) + merge_count_inv(a, m, r);
    vector<long long> tmp;
    int i = l, j = m;
    while (i < m && j < r) {
        if (a[i] <= a[j]) tmp.push_back(a[i++]);
        else {
            tmp.push_back(a[j++]);
            inv += (m - i); // all remaining in left are inversions
        }
    }
    while (i < m) tmp.push_back(a[i++]);
    while (j < r) tmp.push_back(a[j++]);
    for (int k = l; k < r; ++k) a[k] = tmp[k - l];
    return inv;
}
long long count_inversions(vector<long long> a) {
    return merge_count_inv(a, 0, (int)a.size());
}

/* =========================
   8) Count distinct elements in an array
   ========================= */
int count_distinct(const vector<long long>& a) {
    unordered_set<long long> s(a.begin(), a.end());
    return (int)s.size();
}

/* =========================
   Additional Q1: count pairs with diff K
   Use sorting + two-pointer (O(n log n))
   ========================= */
long long count_pairs_with_diff_k(vector<int> a, int K) {
    sort(a.begin(), a.end());
    int n = (int)a.size();
    int i = 0, j = 0;
    long long count = 0;
    while (i < n && j < n) {
        if (i == j) { ++j; continue; }
        long long diff = (long long)a[j] - a[i];
        if (diff == K) {
            ++count;
            ++i; ++j;
        } else if (diff < K) ++j;
        else ++i;
    }
    return count;
}

/* =========================
   Additional Q2: String Split Challenge
   Check if s can be split into three non-empty parts where one part is substring of both others.
   Brute force over splits and check all three possibilities as the 'middle' substring.
   ========================= */
bool string_split_challenge(const string& s) {
    int n = (int)s.size();
    // splits: choose i, j such that s[0..i-1], s[i..j-1], s[j..n-1] are non-empty
    for (int i = 1; i <= n-2; ++i) {
        for (int j = i+1; j <= n-1; ++j) {
            string A = s.substr(0,i), B = s.substr(i, j-i), C = s.substr(j);
            if (A.empty() || B.empty() || C.empty()) continue;
            // check if A is substring of B and C, or B is substring of A and C, or C substring of A and B
            if (B.find(A) != string::npos && C.find(A) != string::npos) return true;
            if (A.find(B) != string::npos && C.find(B) != string::npos) return true;
            if (A.find(C) != string::npos && B.find(C) != string::npos) return true;
        }
    }
    return false;
}

/* =========================
   Additional Q3: Anagram check
   ========================= */
bool are_anagrams(const string& s1, const string& s2) {
    if (s1.size() != s2.size()) return false;
    array<int,26> cnt{};
    cnt.fill(0);
    for (char c : s1) cnt[c - 'a']++;
    for (char c : s2) {
        if (--cnt[c - 'a'] < 0) return false;
    }
    return true;
}

/* =========================
   Additional Q4: Sort array of 0s,1s,2s (Dutch National Flag)
   ========================= */
void dutch_national_flag(vector<int>& a) {
    int low=0, mid=0, high=(int)a.size() - 1;
    while (mid <= high) {
        if (a[mid] == 0) swap(a[low++], a[mid++]);
        else if (a[mid] == 1) mid++;
        else swap(a[mid], a[high--]);
    }
}

/* =========================
   Additional Q5: Duplicate each occurrence of 2 in-place (similar to duplicate zeros)
   We shift elements to the right, elements beyond original length are not written.
   ========================= */
void duplicate_twos(vector<int>& arr) {
    int n = (int)arr.size();
    int possible = 0;
    for (int i = 0; i < n; ++i) {
        if (arr[i] == 2) possible++;
    }
    int i = n-1, j = n + possible -1;
    // work backward
    while (i < j) {
        if (j < n) arr[j] = arr[i];
        if (arr[i] == 2) {
            --j;
            if (j < n) arr[j] = 2;
        }
        --i; --j;
    }
}

/* =========================
   Helper: print vector
   ========================= */
template<typename T>
void print_vec(const vector<T>& v) {
    for (auto &x : v) cout << x << " ";
    cout << "\n";
}

/* =========================
   main: demonstrates each function with small examples
   Replace inputs or remove demonstrations as desired.
   ========================= */
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cout << "=== Assignment solutions demonstration ===\n\n";

    // 1) Binary search
    vector<int> bs = {1,3,5,7,9,11,13};
    cout << "Binary search for 7 in {1,3,5,7,9,11,13}: index = " << binary_search_iter(bs,7) << "\n\n";

    // 2) Bubble sort with given elements
    vector<int> arr = {64,34,25,12,22,11,90};
    cout << "Bubble sort input: "; print_vec(arr);
    bubble_sort(arr);
    cout << "Bubble sort output: "; print_vec(arr);
    cout << "\n";

    // 3) Missing number
    vector<int> m1 = {1,2,3,4,6,7}; int n = 7;
    cout << "Missing (linear) -> " << missing_linear(m1,n) << "\n";
    cout << "Missing (binary) -> " << missing_binary(m1,n) << "\n\n";

    // 4) String programs
    string s1 = "Hello", s2 = "World";
    cout << "Concat: " << concat_strings(s1,s2) << "\n";
    cout << "Reverse of 'Hello' = " << reverse_string(s1) << "\n";
    cout << "Delete vowels from 'beautiful' = " << delete_vowels(string(\"beautiful\")) << "\n";
    vector<string> ss = {\"banana\",\"apple\",\"cherry\"};
    auto ss_sorted = sort_strings_alphabetical(ss);
    cout << "Sorted strings: "; for (auto &x:ss_sorted) cout<<x<<\" \"; cout << \"\\n\";
    cout << \"Upper->lower of 'A' = \" << upper_to_lower('A') << \"\\n\\n\";

    // 5) Matrix storages demo
    DiagonalMatrix D(4);
    D.set(0,0,5); D.set(1,1,10); D.set(2,2,15); D.set(3,3,20);
    cout << \"Diagonal[2][2] = \" << D.get(2,2) << \"\\n\";

    TriDiagonal T(4);
    T.set(0,0,1); T.set(0,1,2); T.set(1,0,3); T.set(1,1,4); T.set(1,2,5);
    cout << \"TriDiagonal[1][2] = \" << T.get(1,2) << \"\\n\";

    LowerTriangular L(4);
    L.set(2,1,7);
    cout << \"LowerTri[2][1] = \" << L.get(2,1) << \"\\n\";

    UpperTriangular U(4);
    U.set(0,3,9);
    cout << \"UpperTri[0][3] = \" << U.get(0,3) << \"\\n\";

    SymmetricMatrix S(3);
    S.set(0,1,8);
    cout << \"Symmetric[1][0] = \" << S.get(1,0) << \"\\n\\n\";

    // 6) Sparse triplet demo
    SparseTriplet A(2,3);
    A.add_triplet(0,0,1); A.add_triplet(0,2,2); A.add_triplet(1,1,3);
    cout << \"Original sparse A:\\n\"; A.print();
    auto At = A.transpose();
    cout << \"Transpose:\\n\"; At.print();

    SparseTriplet B(2,3);
    B.add_triplet(0,0,4); B.add_triplet(1,1,5);
    cout << \"B:\\n\"; B.print();
    auto C = A.add(B);
    cout << \"A + B:\\n\"; C.print();

    // Multiplication demo (2x3 * 3x2)
    SparseTriplet M1(2,3);
    M1.add_triplet(0,0,1); M1.add_triplet(0,2,2); M1.add_triplet(1,1,3);
    SparseTriplet M2(3,2);
    M2.add_triplet(0,1,4); M2.add_triplet(2,0,5);
    cout << \"M1 * M2:\\n\";
    auto M3 = M1.multiply(M2);
    M3.print();
    cout << \"\\n\";

    // 7) Count inversions
    vector<long long> invArr = {2,4,1,3,5};
    cout << \"Inversions in {2,4,1,3,5} = \" << count_inversions(invArr) << \"\\n\";

    // 8) Distinct count
    vector<long long> d = {1,2,2,3,4,1};
    cout << \"Distinct count = \" << count_distinct(d) << \"\\n\\n\";

    // Additional 1) pairs difference K
    vector<int> p = {1,5,3,4,2};
    cout << \"Pairs with diff 2 = \" << count_pairs_with_diff_k(p,2) << \"\\n\";

    // Additional 2) string split
    cout << \"String split challenge for 'ababa' => \" << (string_split_challenge(\"ababa\")?\"YES\":\"NO\") << \"\\n\";

    // Additional 3) anagrams
    cout << \"Are 'listen' and 'silent' anagrams? \" << (are_anagrams(\"listen\",\"silent\")?\"YES\":\"NO\") << \"\\n\";

    // Additional 4) dutch flag
    vector<int> dnf = {2,0,2,1,1,0};
    dutch_national_flag(dnf);
    cout << \"Dutch flag sorted: \"; print_vec(dnf);

    // Additional 5) duplicate twos
    vector<int> dt = {1,2,3,2,4,5};
    cout << \"Before duplicate_twos: \"; print_vec(dt);
    duplicate_twos(dt);
    cout << \"After duplicate_twos: \"; print_vec(dt);

    cout << \"\\n=== End of demonstration ===\\n\";
    return 0;
}
